# SETUP REQUIRED:
# ===============
# Repository Secrets (Settings > Secrets and variables > Actions):
# - DEV_ENVIRONMENT_URL: Your development environment URL (e.g., https://yourorg-dev.crm.dynamics.com)
# - PROD_ENVIRONMENT_URL: Your production environment URL (e.g., https://yourorg.crm.dynamics.com)
# - POWER_PLATFORM_SP_APP_ID: Service principal Application (client) ID
# - POWER_PLATFORM_SP_CLIENT_SECRET: Service principal client secret
# - POWER_PLATFORM_TENANT_ID: Azure AD tenant ID
#
# Repository Variables (Settings > Secrets and variables > Actions > Variables):
# - ENABLE_TEAMS_CHANNEL: Set to 'true' to enable Teams channel configuration
# - ENABLE_WEBSITE_CHANNEL: Set to 'true' to enable Website channel configuration
# - SHARE_WITH_GROUP: Group name to share agents with (optional, defaults to 'All Company')
#
# Service Principal Setup:
# 1. Run: az ad sp create-for-rbac --name "GitHubActions-PowerPlatform" --role contributor
# 2. In Azure AD, assign "Power Platform Administrator" role
# 3. Grant API permissions for Power Platform services

name: Power Platform Solution Deployment

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - test

env:
  SOLUTION_NAME: 'TestAutomationSolution'  # Replace with your actual solution name
  SOLUTION_EXPORTED_FOLDER: 'out/exported/'
  SOLUTION_FOLDER: 'out/solutions/'
  SOLUTION_TARGET_FOLDER: 'solutions/'

jobs:
  export-from-dev:
    runs-on: windows-latest
    env:
      RUNNER_DEBUG: 1

    steps:
    - uses: actions/checkout@v4
      with:
        lfs: true

    - name: Setup Power Platform CLI
      uses: microsoft/powerplatform-actions/actions-install@v1

    - name: Export solution
      uses: microsoft/powerplatform-actions/export-solution@v1
      with:
        environment-url: ${{ secrets.DEV_ENVIRONMENT_URL }}
        app-id: ${{ secrets.POWER_PLATFORM_SP_APP_ID }}
        client-secret: ${{ secrets.POWER_PLATFORM_SP_CLIENT_SECRET }}
        tenant-id: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
        solution-name: ${{ env.SOLUTION_NAME }}
        solution-output-file: ${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}.zip
        managed: false

    - name: Unpack solution
      uses: microsoft/powerplatform-actions/unpack-solution@v1
      with:
        solution-file: ${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}.zip
        solution-folder: ${{ env.SOLUTION_FOLDER }}/${{ env.SOLUTION_NAME }}
        solution-type: 'Unmanaged'
        overwrite-files: true

    - name: Upload exported solution as artifact
      uses: actions/upload-artifact@v4
      with:
        name: exportedsolution
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}

    - name: Upload unpacked solution as artifact
      uses: actions/upload-artifact@v4
      with:
        name: unpackedsolution
        path: ${{ env.SOLUTION_FOLDER }}

  build-managed-solution:
    needs: [ export-from-dev ]
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        lfs: true

    - name: Download exported solution artifact
      uses: actions/download-artifact@v4
      with:
        name: exportedsolution
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}

    - name: Setup Power Platform CLI
      uses: microsoft/powerplatform-actions/actions-install@v1

    - name: Debug exported solution
      run: |
        Write-Host "=== Debugging Exported Solution ==="
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "SOLUTION_EXPORTED_FOLDER: ${{ env.SOLUTION_EXPORTED_FOLDER }}"
        Write-Host "SOLUTION_NAME: ${{ env.SOLUTION_NAME }}"
        
        if (Test-Path "${{ env.SOLUTION_EXPORTED_FOLDER }}") {
          Write-Host "Contents of SOLUTION_EXPORTED_FOLDER:"
          Get-ChildItem "${{ env.SOLUTION_EXPORTED_FOLDER }}" | Select-Object Name, Length
        } else {
          Write-Host "SOLUTION_EXPORTED_FOLDER does not exist!"
        }
        
        $exportedSolutionPath = "${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}.zip"
        if (Test-Path $exportedSolutionPath) {
          Write-Host "Found exported solution: $exportedSolutionPath"
          Write-Host "File size: $((Get-Item $exportedSolutionPath).Length) bytes"
        } else {
          Write-Host "Exported solution not found at: $exportedSolutionPath"
        }
      shell: pwsh

    - name: Convert to managed solution using CLI
      run: |
        Write-Host "=== Converting Solution to Managed ==="
        $exportedSolutionPath = "${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}.zip"
        $managedSolutionPath = "${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}_managed.zip"
        $tempUnpackFolder = "temp_unpack"
        
        try {
          if (Test-Path $exportedSolutionPath) {
            Write-Host "Converting $exportedSolutionPath to managed..."
            
            # First unpack the solution
            Write-Host "Step 1: Unpacking solution..."
            pac solution unpack --zipfile $exportedSolutionPath --folder $tempUnpackFolder --packagetype Unmanaged
            
            # Then pack as managed
            Write-Host "Step 2: Packing as managed solution..."
            pac solution pack --zipfile $managedSolutionPath --folder $tempUnpackFolder --packagetype Managed
            
            if (Test-Path $managedSolutionPath) {
              Write-Host "‚úÖ Managed solution created successfully: $managedSolutionPath"
              Write-Host "File size: $((Get-Item $managedSolutionPath).Length) bytes"
            } else {
              throw "Failed to create managed solution"
            }
          } else {
            throw "Source solution not found: $exportedSolutionPath"
          }
        }
        catch {
          Write-Host "‚ùå Error during solution conversion: $_"
          Write-Host "Attempting alternative method using PowerPlatform actions..."
          
          # Clean up temp folder if it exists
          if (Test-Path $tempUnpackFolder) {
            Remove-Item $tempUnpackFolder -Recurse -Force
          }
          
          # Alternative: Try direct copy and rename (for testing)
          if (Test-Path $exportedSolutionPath) {
            Write-Host "Using exported solution as managed (fallback method)..."
            Copy-Item $exportedSolutionPath $managedSolutionPath
            Write-Host "‚úÖ Fallback: Copied solution as managed"
          } else {
            Write-Host "‚ùå Critical error: No solution file available"
            exit 1
          }
        }
        finally {
          # Clean up temp folder
          if (Test-Path $tempUnpackFolder) {
            Remove-Item $tempUnpackFolder -Recurse -Force
            Write-Host "Cleaned up temporary folder"
          }
        }
      shell: pwsh

    - name: Upload managed solution as artifact
      uses: actions/upload-artifact@v4
      with:
        name: managedsolution
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}_managed.zip

  deploy-to-production:
    needs: [ build-managed-solution ]
    runs-on: windows-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment: production

    steps:
    - uses: actions/checkout@v4
      with:
        lfs: true

    - name: Download managed solution artifact
      uses: actions/download-artifact@v4
      with:
        name: managedsolution
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}

    - name: Setup Power Platform CLI
      uses: microsoft/powerplatform-actions/actions-install@v1

    - name: Import solution to Production
      uses: microsoft/powerplatform-actions/import-solution@v1
      with:
        environment-url: ${{ secrets.PROD_ENVIRONMENT_URL }}
        app-id: ${{ secrets.POWER_PLATFORM_SP_APP_ID }}
        client-secret: ${{ secrets.POWER_PLATFORM_SP_CLIENT_SECRET }}
        tenant-id: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
        solution-file: ${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}_managed.zip
        force-overwrite: true
        publish-changes: true
        skip-dependency-check: false

    - name: Post-Deployment Agent Configuration
      if: success()
      shell: pwsh
      run: |
        Write-Host "ü§ñ Starting Post-Deployment Agent Configuration..." -ForegroundColor Green
        
        # Use the dedicated PowerApps module installation script
        Write-Host "üîß Installing PowerApps modules using dedicated script..." -ForegroundColor Cyan
        try {
          & "${{ github.workspace }}\scripts\install-powerapps-modules.ps1" -Verbose
          Write-Host "‚úÖ PowerApps modules installation completed" -ForegroundColor Green
        } catch {
          Write-Host "‚ö†Ô∏è PowerApps module installation script failed, trying fallback method..." -ForegroundColor Yellow
          Write-Host "Error details:" -ForegroundColor Red
          Write-Host $_.Exception.Message -ForegroundColor Red
          
          # Fallback: Basic PowerShell environment setup
          Write-Host "üîß Setting up PowerShell environment (fallback)..." -ForegroundColor Cyan
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
          
          # Try to install NuGet package provider with fallback
          try {
            Write-Host "Installing NuGet package provider..." -ForegroundColor Yellow
            Install-PackageProvider -Name "NuGet" -MinimumVersion "2.8.5.201" -Force -Scope CurrentUser -ErrorAction Stop
            Write-Host "‚úÖ NuGet package provider installed successfully" -ForegroundColor Green
          } catch {
            Write-Host "‚ö†Ô∏è NuGet package provider installation failed, continuing without it..." -ForegroundColor Yellow
            Write-Host "Error details:" -ForegroundColor Red
            Write-Host $_.Exception.Message -ForegroundColor Red
          }
          
          # Install PowerApps modules with enhanced error handling
          Write-Host "üì¶ Installing PowerApps PowerShell modules..." -ForegroundColor Cyan
          $modules = @(
            "Microsoft.PowerApps.Administration.PowerShell",
            "Microsoft.PowerApps.PowerShell"
          )
          
          foreach ($module in $modules) {
            Write-Host "Installing $module..." -ForegroundColor Yellow
            $installed = $false
            
            # Method 1: Try Install-Module
            try {
              Install-Module -Name $module -Repository PSGallery -Force -AllowClobber -Scope CurrentUser -AcceptLicense -ErrorAction Stop
              Import-Module -Name $module -Force -ErrorAction Stop
              Write-Host "‚úÖ Successfully installed $module via Install-Module" -ForegroundColor Green
              $installed = $true
            } catch {
              Write-Host "‚ö†Ô∏è Install-Module failed for $module`: $($_.Exception.Message)" -ForegroundColor Yellow
            }
            
            # Method 2: Try Install-Package if Install-Module failed
            if (-not $installed) {
              try {
                Install-Package -Name $module -Source PowerShellGallery -Force -Scope CurrentUser -ErrorAction Stop
                Import-Module -Name $module -Force -ErrorAction Stop
                Write-Host "‚úÖ Successfully installed $module via Install-Package" -ForegroundColor Green
                $installed = $true
              } catch {
                Write-Host "‚ö†Ô∏è Install-Package failed for $module`: $($_.Exception.Message)" -ForegroundColor Yellow
              }
            }
            
            # Method 3: Try Find-Module and install without NuGet provider
            if (-not $installed) {
              try {
                $moduleInfo = Find-Module -Name $module -Repository PSGallery -ErrorAction Stop
                Save-Module -Name $module -Path "$env:USERPROFILE\Documents\PowerShell\Modules" -Force -ErrorAction Stop
                Import-Module -Name $module -Force -ErrorAction Stop
                Write-Host "‚úÖ Successfully installed $module via Save-Module" -ForegroundColor Green
                $installed = $true
              } catch {
                Write-Host "‚ö†Ô∏è Save-Module failed for $module`: $($_.Exception.Message)" -ForegroundColor Yellow
              }
            }
            
            if (-not $installed) {
              Write-Warning "‚ùå Could not install $module with any method. Script will use REST API fallbacks."
            }
          }
        }
        
        # Verify module installation
        Write-Host "üîç Verifying PowerApps modules..." -ForegroundColor Cyan
        $modules = @("Microsoft.PowerApps.Administration.PowerShell", "Microsoft.PowerApps.PowerShell")
        foreach ($module in $modules) {
          $loadedModule = Get-Module -Name $module -ErrorAction SilentlyContinue
          if ($loadedModule) {
            Write-Host "‚úÖ $module loaded (Version: $($loadedModule.Version))" -ForegroundColor Green
          } else {
            Write-Host "‚ö†Ô∏è $module not loaded - REST API fallbacks will be used" -ForegroundColor Yellow
          }
        }
        
        # Run the post-deployment script
        Write-Host "üöÄ Running agent configuration script..." -ForegroundColor Green
        try {
          ${{ github.workspace }}/scripts/post-deploy-agent.ps1 `
            -EnvironmentUrl "${{ secrets.PROD_ENVIRONMENT_URL }}" `
            -ClientId "${{ secrets.POWER_PLATFORM_SP_APP_ID }}" `
            -ClientSecret "${{ secrets.POWER_PLATFORM_SP_CLIENT_SECRET }}" `
            -TenantId "${{ secrets.POWER_PLATFORM_TENANT_ID }}" `
            -PublishAgent $true `
            -EnableAgent $true
          Write-Host "‚úÖ Agent configuration completed successfully!" -ForegroundColor Green
        } catch {
          Write-Host "‚ùå Agent configuration failed" -ForegroundColor Red
          Write-Host $_.Exception.Message -ForegroundColor Red
          throw
        }

    - name: Configure Agent Channels
      if: success() && (vars.ENABLE_TEAMS_CHANNEL == 'true' || vars.ENABLE_WEBSITE_CHANNEL == 'true')
      shell: pwsh
      run: |
        $channels = @()
        if ("${{ vars.ENABLE_TEAMS_CHANNEL }}" -eq "true") { $channels += "Teams" }
        if ("${{ vars.ENABLE_WEBSITE_CHANNEL }}" -eq "true") { $channels += "Website" }
        
        ${{ github.workspace }}/scripts/configure-agent-channels.ps1 `
          -EnvironmentUrl "${{ secrets.PROD_ENVIRONMENT_URL }}" `
          -ClientId "${{ secrets.POWER_PLATFORM_SP_APP_ID }}" `
          -ClientSecret "${{ secrets.POWER_PLATFORM_SP_CLIENT_SECRET }}" `
          -TenantId "${{ secrets.POWER_PLATFORM_TENANT_ID }}" `
          -EnableChannels $channels `
          -ShareWithGroup "${{ vars.SHARE_WITH_GROUP || 'All Company' }}"

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Solution and Agent deployed successfully to production!"
          echo "ü§ñ Agent is now published and ready for use!"
        else
          echo "‚ùå Solution deployment failed!"
          exit 1
        fi

  run-solution-checker:
    needs: [ export-from-dev ]
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4

    - name: Download exported solution artifact
      uses: actions/download-artifact@v4
      with:
        name: exportedsolution
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}

    - name: Setup Power Platform CLI
      uses: microsoft/powerplatform-actions/actions-install@v1

    - name: Run Solution Checker
      uses: microsoft/powerplatform-actions/check-solution@v1
      with:
        environment-url: ${{ secrets.DEV_ENVIRONMENT_URL }}
        app-id: ${{ secrets.POWER_PLATFORM_SP_APP_ID }}
        client-secret: ${{ secrets.POWER_PLATFORM_SP_CLIENT_SECRET }}
        tenant-id: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
        path: ${{ env.SOLUTION_EXPORTED_FOLDER }}/${{ env.SOLUTION_NAME }}.zip
        checker-logs-artifact-name: 'solution-checker-logs'
